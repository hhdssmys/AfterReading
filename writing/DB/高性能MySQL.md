#### 索引
```
索引是存储引擎实现的

三星系统：（索引优化可能提供数量级上的优化）
一星索引：索引将相关的记录放到一起
二星索引：索引中的数据顺序和查找中的排列顺序一致（索引列的顺序意味着索引会按照最左列排序，其次是第二列等等）
三星索引：索引中的列包含了查询中需要的全部列（不用回表）

理解 B+ 树的结构对于聚簇索引非常重要
B+ 树，非叶子节点只存索引列信息，用于树的比较查找，所有的行记录信息都存在叶子节点上。还有页裂变等概念也很重要（按页顺序存储有利于减少随机 I/O ）
对于聚簇索引，叶子节点不仅存索引列，还存数据，聚簇索引就是表（因为数据不能同时存在于两处，所以就是表），索引列就是主键
对于非聚簇索引（二级索引），叶子节点存索引列，行号（不支持聚簇索引的引擎）或者 主键列（支持聚簇索引的引擎，便于更新数据后，行号发生变化时，不用更新二级索引）
[略读了这篇文章，较好的理解了 B+ 树](https://juejin.im/entry/5b0cb64e518825157476b4a9#b-%E6%A0%91)


B+ 树索引是数据结构，一般侧重点是说明比较查找的，但是却是主要的实现方式
聚簇索引是侧重点在一种存储方式，数据关联在索引上
覆盖查询：索引列需要包含查询字段的值（聚簇索引被关联的数据不是索引列），（所以哈希，空间，全文索引这些不存储索引值的就不能作为他的实现，B+树就是唯一实现）




由于底层存储引擎 API 限制，MySQL 5.5版本前，只允许索引做简单的比较操作（等于，不等于，大于）
后来引擎可以做索引的最左前缀匹配的 like 比较（是因为该操作可以转化为简单的比较操作），一旦 like 以
通配符开头的 like 查询，存储引擎无法匹配，这是只能提取数据行的值进行比较而非索引值比较


目前过滤条件只能在服务器层处理，不能在存储引擎层处理
所以只能把数据拉取到服务器层做过滤，（这里存在很大的传输消耗）

索引不能覆盖查询所需的全部列时，就需要每扫描一条索引然后回表查询一次对应的行，这是随机 I/O

MySQL排序方式：
1.排序操作 
2.按索引顺序扫描（多表关联时，只有order by 全是第一张表的字段才能使用索引做排序，sql语句写在前面不代表就是第一张表）
（索引的列顺序必须和order by 的字段顺序一模一样，满足最左前缀要求，如果前导列是常量时，可以跳过改索引列）

InnoDB 在二级索引上使用共享（读）锁，在主键索引（聚簇索引）上使用排它（写）锁
InnoDB 只有在访问行时才会加锁，而索引可以减少回表查询的行数，也就减少了锁的数量
myisam 默认压缩索引，默认只压缩字符串，也可以修改压缩整数，不支持聚簇索引
innodb 不压缩索引，支持聚簇索引，主键默认就是，如果没有定义主键，则选择一个唯一非空索引代替，如果也没有，innodb 会定义一个隐式主键做聚簇索引
      innodb 的二级索引关联了主键列，所以支持主键列的覆盖与排序，但是在二级索引的最后（最右）
	  innodb 的数据文件就是一个索引文件
```
